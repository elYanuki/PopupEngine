class PopupEngine{
	static modal = document.createElement("div")
	static modalContent = document.createElement("div")
	static inline = document.createElement("div")

	static initialized = false
	static config = {
		doLogs: true,
		preferedInlinePopupPosition: "top",
	}

	static endModal
	static observer

	static init(config){
		if(this.initialized == true){
			if(this.config.doLogs)
			console.log("PopupEngine is already initialized, will ignore this call.")
			return
		}

		//configure the engine
		if(config){
			if(config.doLogs)
				this.config.doLogs = config.doLogs
			if(config.preferedInlinePopupPosition)
				this.config.preferedInlinePopupPosition = config.preferedInlinePopupPosition
		}

		//create needed html
		this.modal.classList.add("popupEngineModalContainer")
		this.modal.style.display = "none"
		this.modalContent.classList.add("popupEngineModalContent")
		this.modal.appendChild(this.modalContent)

		this.inline.classList.add("popupEngineInlineContainer")
		this.inline.style.scale = 0

		if (document.readyState === 'complete' || document.readyState === 'interactive') {
			this.addDOMElems()
		} 
		else {
			window.addEventListener('load', ()=>{
				this.addDOMElems()
			});
		}
	}

	static addDOMElems(){
		document.body.appendChild(document.createComment('Code generated by popupEngine'))
		document.body.appendChild(this.modal)
		document.body.appendChild(this.inline)

		this.createCSS()
		this.createDOMchangeListener()

		//add hover listeners to existing elements that request inline popups
		document.querySelectorAll('*[data-popupText]').forEach((element)=>{
			this.addHoverListeners(element)
		})

		this.initialized = true
	}

	static createCSS(){
		//create stylesheet
		const style = document.createElement('style')
		document.head.appendChild(style)

		const stylesheet = style.sheet

		//----------- modal -----------//
		//#region 
		stylesheet.insertRule(`:where(.popupEngineModalContainer){
			position: fixed;
			inset: 0;
			background-color: hsla(0,0%,0%,.3);
			z-index: 1000;
			display: none;
			place-content: center;
			font-family: sans-serif;
			color: var(--popupEngine-color);
			transition: opacity .3s;
			opacity:0;
			backdrop-filter: blur(4px);

			--popupEngine-background-color: white;
			--popupEngine-color: black;
		}`)

		stylesheet.insertRule(`:where(.popupEngineModalContent) { 
			background-color: var(--popupEngine-background-color);
			padding: 2vw 5vw;
			max-width: 90vw;
			min-width: 25vw;
			overflow: hidden;
			word-wrap: break-word;
			transition: scale .3s;
			transition-timing-function: cubic-bezier(.13,.68,.46,1.33);
			scale: 0; 
		}`)

		stylesheet.insertRule(`:where(.popupEngineModalHeading) {
			text-align: center;
			font-size: 1.5rem
		}`)

		stylesheet.insertRule(`:where(.popupEngineModalText) {
			text-align: center;
			margin-bottom: 1rem;
		}`)
		
		stylesheet.insertRule(`:where(.popupEngineModalInputs) {
			display: flex;
				flex-direction: column;
				justify-content: center;
		}`)
		
		stylesheet.insertRule(`:where(.popupEngineModalInput) {
			padding: .5rem;
			border: 1px solid gray;
			margin: .2rem 0 .5rem 0;
			color: var(--popupEngine-color);
		}`)
		
		stylesheet.insertRule(`:where(.popupEngineModalInputLabel) {
			font-size: .9rem;
		}`)
		
		stylesheet.insertRule(`:where(.popupEngineModalButtons) {
			display: flex;
				flex-wrap: wrap;
				gap: 1rem;
				justify-content: center;
		}`)
		
		stylesheet.insertRule(`:where(.popupEngineModalButton) {
			cursor: pointer;
			border: 1px solid gray;
			padding: .5rem;
			color: var(--popupEngine-color);
		}`)
		//#endregion
		
		//----------- inline -----------//

		//#region 

		stylesheet.insertRule(`:where(.popupEngineInlineContainer) { 
			position: fixed;
			z-index: 1000;
			display: grid;
			place-items: center;
			top: 0;
			transition: scale .3s;

			--popupEngine-background-color: white;
		}`)

		stylesheet.insertRule(`:where(.popupEngineInlineContent) { 
			background-color: var(--popupEngine-background-color);
			padding: .65rem;
			max-width: 30vw;
			word-wrap: break-word;
			transition: scale .3s;
			transition-timing-function: cubic-bezier(.13,.68,.46,1.33);
			box-shadow: 0 0 .3rem .3rem rgba(0,0,0,.1);
			grid-area: 1 / 1 / 2 / 2;
			transform: translateX(0);
		}`)

		stylesheet.insertRule(`:where(.popupEngineInlinePointer) { 
			content: "";
			background-color: var(--popupEngine-background-color);
			transform: rotate(45deg) translateY(50%);
			box-shadow: 0 0 .3rem .3rem rgba(0,0,0,.1);
			aspect-ratio: 1;
			width: 1rem;
			grid-area: 1 / 1 / 2 / 2;
			align-self: end;
		}`)
		stylesheet.insertRule(`.popupEngineInlineContainer.atBottom .popupEngineInlinePointer { 
			transform: translateY(-40%) rotate(45deg);
			align-self: start;
		}`)

		stylesheet.insertRule(`:where(.popupEngineInlineText) {
			margin: 0;
		}`)

		stylesheet.insertRule(`:where(.popupEngineInlineHeading) {
			text-align: center;
			font-size: 1.2rem;
			margin: 0 0 .5rem 0;
		}`)

		//#endregion
	}

	static createDOMchangeListener(){
		// Options for the observer (which mutations to observe)
		const config = { attributes: true, childList: true, subtree: true }

		let relevantAttributes = ["data-popuptext", "data-popupheading", "data-autocreatepopup"]

		// Callback function to execute when mutations are observed
		const callback = (mutationList, observer) => {
			for (const mutation of mutationList) {
				console.log(mutation.attributeName)
				if (mutation.type === "childList" || relevantAttributes.includes(mutation.attributeName)) {
					console.log("mutation detected")

					mutation.addedNodes.forEach((elem)=>{
						if(elem.dataset.popuptext != undefined){
							this.addHoverListeners(elem)
						}
					}) 
				}
			}
		};

		// Create an observer instance linked to the callback function
		this.observer = new MutationObserver(callback)

		// Start observing the target node for configured mutations
		this.observer.observe(document, config)
	}

	static addHoverListeners(elem){
		if(elem.dataset.autocreatepopup === "false")
			return

		elem.addEventListener("mouseenter", ()=>{this.createInlinePopup({
			position: elem, 
			text: elem.dataset.popuptext, 
			heading: elem.dataset.popupheading,
			element: elem
		})})
		elem.addEventListener("mouseleave", ()=>{this.closeInlinePopup(elem)})
	}

	static createInlinePopup(settings){
		if(!this.checkHTML || !settings )return

		if(!settings.position){
			if(this.config.doLogs)
				console.error("position setting is required: either a element or a mouse event")
			return
		}

		this.observer.disconnect()

		this.inline.innerHTML = ""

		let content = document.createElement('div')
		content.classList.add("popupEngineInlineContent")

		//create heading
		if(settings.heading){
			let heading = document.createElement("p")
			heading.innerHTML = settings.heading
			heading.classList.add("popupEngineInlineHeading")

			content.appendChild(heading)
		}

		//generate text
		let popupText = document.createElement("p")
		popupText.classList.add("popupEngineInlineText")
		popupText.innerHTML = settings.text || "no text specified"

		content.appendChild(popupText)

		let pointer = document.createElement('div')
		pointer.classList.add("popupEngineInlinePointer")
		this.inline.appendChild(pointer)

		this.inline.appendChild(content)

		if(settings.position instanceof Element){
			let rect = settings.position.getBoundingClientRect();

			let topValue = rect.top - rect.height - this.inline.offsetHeight + 5
			if(topValue < 0){
				topValue = rect.top + rect.height + 10
				this.inline.classList.add("atBottom")
			}
			else{
				this.inline.classList.remove("atBottom")
			}

			if(this.config.preferedInlinePopupPosition == "bottom"){
				topValue = rect.top + rect.height + 10
				this.inline.classList.add("atBottom")
			}

			this.inline.style.top = topValue + "px"
			this.inline.style.left = `max(${rect.left - this.inline.offsetWidth/2 + rect.width/2}px, 0px)`

			settings.position.classList.add("popupVisible")
		}
		else if(settings.position.clientX){
			let topValue = settings.position.clientY - this.inline.offsetHeight - 10
			if(topValue < 0){
				topValue = settings.position.clientY + 10
				this.inline.classList.add("atBottom")
			}
			else{
				this.inline.classList.remove("atBottom")
			}

			this.inline.style.top = topValue + "px"
			this.inline.style.left = `max(${settings.position.clientX - this.inline.offsetWidth/2}px, 0px)`
		}

		settings?.element.classList.add("popupVisible")

		this.inline.style.scale = 1
	}

	static closeInlinePopup(elem){
		elem.classList.remove("popupVisible")
		this.inline.style.scale = 0
		this.createDOMchangeListener()
	}

	static createModal(settings = {}){
		return new Promise((resolve, reject) => {
			this.endModal = resolve
	
			if(!this.checkHTML)return
	
			if(this.modal.style.display != "none"){
				if(this.config.doLogs)
				console.log('overwriting old popup: "' + this.modalContent.querySelector(".popupEngineModalText").innerHTML + '"')
			}
			
			//#region generate content

			this.modalContent.innerHTML = ""

			//create heading
			if(settings.heading){
				let heading = document.createElement("p")
				heading.innerHTML = settings.heading
				heading.classList.add("popupEngineModalHeading")

				this.modalContent.appendChild(heading)
			}

			//generate text
			let popupText = document.createElement("p")
			popupText.classList.add("popupEngineModalText")
			popupText.innerHTML = settings.text || "no text specified"
	
			this.modalContent.appendChild(popupText)

			//create input
			if(!settings.inputs || settings.inputs.length == 0){
				settings.inputs = []
			}

			let popupInputs = document.createElement("div")
			popupInputs.classList.add("popupEngineModalInputs")

			for (let i = 0; i < settings.inputs.length; i++) {
				let input = document.createElement("input")

				if(settings.inputs[i].label){
					input.name = i

					let label = document.createElement("label")
					label.classList.add("popupEngineModalInputLabel")
					label.innerText = settings.inputs[i].label

					popupInputs.appendChild(label)
				}

				input.classList.add("popupEngineModalInput")
				input.type = settings.inputs[i].type || "text"
				input.placeholder = settings.inputs[i].placeholder || ""
	
				popupInputs.appendChild(input)
			}
	
			this.modalContent.appendChild(popupInputs)
			
			//create buttons
			if(!settings.buttons || settings.buttons.length == 0){
				settings.buttons = [{text: "okay"}]
			}
	
			let popupButtons = document.createElement("div")
			popupButtons.classList.add("popupEngineModalButtons")
			
			for (let i = 0; i < settings.buttons.length; i++) {
				let button = document.createElement("button")
				button.classList.add("popupEngineModalButton")
				button.innerText = settings.buttons[i].text
				button.onclick = function () { 
					PopupEngine.closeModal(
						settings.buttons[i].closePopup, 
						settings.buttons[i].action, 
						{
							text: settings.text,
							heading: settings.heading,
							buttons: settings.buttons,
							inputs: settings.inputs,
							buttonIndex: i,
						}
				)}
	
				popupButtons.appendChild(button)
			}
	
			this.modalContent.appendChild(popupButtons)
	
			//#endregion
	
			//show popup
			this.modal.style.display = "grid"
			setTimeout(function(){
				document.querySelector('.popupEngineModalContainer').style.opacity = 1
				document.querySelector('.popupEngineModalContent').style.scale = 1
			},0)
		})
	}

	static closeModal(closePopup = true, closeAction, data){
		//get values of inputs
		if(this.modalContent.querySelector(".popupEngineModalInputs")){
			let inputValues = []
			document.querySelectorAll('.popupEngineModalInputs .popupEngineModalInput').forEach(item => {
				inputValues.push(item.value)
			})
			data.inputValues = inputValues
		}

		if(closeAction){
			closeAction(data)
		}

		if(closePopup){
			this.modal.style.display = "none"
			this.modal.style.opacity = 0
			this.modalContent.style.scale = 0

			this.endModal(data)
		}
	}

	static checkHTML(){
		if (document.readyState === 'loading') {
			if(this.config.doLogs)
			console.error("PopupEngine cant be run before DOM content has finished loading. Try adding a window.load() event arround this call or use defer.")
			return false
		} 

		if(!this.initialized){
			if(this.config.doLogs)
			console.error("PopupEngine has not yet been initialized: PopupEngine.init(). \n try running PopupEngine.test()")
			return false
		}
	}

	/**
	 * test method, creates one popup and outputs errors
	 */
	static test(){
		if(!this.initialized){
			console.error("TEST: PopupEngine has not yet been initialized: PopupEngine.init()")
			return
		}
		if(!document.querySelector('.popupEngineModalContainer')){
			console.error("TEST: Could not find DOM elements needed to run PopupEngine. This is probably because the Engine has not yet been initialized: PopupEngine.init()")
			return
		}
		if(!document.querySelector('.popupEngineModalContent')){
			console.error("TEST: Could not find DOM elements needed to run PopupEngine. This might be a problem with the initialization but is probably because another script has changed the engines elements or because your version of the engine is faulty.")
			return
		}
		console.log("TEST: all DOM elements seem fine");
		console.log(
		`TEST: Generating a test popup`);
		PopupEngine.createModal({
			heading: "test",
			text: "this is a test",
			buttons: [
				{
					text: "okay",
					action: (data) => {console.log("buttonpressed, value:", data.inputValues[0])}
				}
			],
			inputs: [
				{
					type: "text",
				}
			]
		})
	}
}